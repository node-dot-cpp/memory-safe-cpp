
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP___LIBCPP_EXTRA
#define _LIBCPP___LIBCPP_EXTRA

#include "__libcpp_config"
#include <memory>
#include <type_traits>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include "__undef_macros"


namespace nodecpp {

// __uncvref

template <class _Tp>
struct __uncvref  {
    typedef typename std::remove_cv<typename std::remove_reference<_Tp>::type>::type type;
};

template <class _Tp>
struct __unconstref {
    typedef typename std::remove_const<typename std::remove_reference<_Tp>::type>::type type;
};

#ifndef _LIBCPP_CXX03_LANG
template <class _Tp>
using __uncvref_t = typename __uncvref<_Tp>::type;
#endif

// __is_same_uncvref

template <class _Tp, class _Up>
struct __is_same_uncvref : std::is_same<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};

#if defined(_LIBCPP_HAS_IS_FINAL)
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
#else
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
__libcpp_is_final : public std::false_type {};
#endif

// These traits are used in __tree and __hash_table
#ifndef _LIBCPP_CXX03_LANG
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : std::conditional<std::is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, std::pair<_First, _Second>>
    : std::conditional<std::is_same<typename std::remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};

// __can_extract_map_key uses true_type/false_type instead of the tags.
// It returns true if _Key != _ContainerValueTy (the container is a map not a set)
// and _ValTy == _Key.
template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : std::integral_constant<bool, std::is_same<_RawValTy, _Key>::value> {};

// This specialization returns __extract_key_fail_tag for non-map containers
// because _Key == _ContainerValueTy
template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : std::false_type {};

#endif


template <class>
struct __void_t { typedef void type; };

#if _LIBCPP_STD_VER > 11
template <class _Tp, class, class = void>
struct __is_transparent : std::false_type {};

template <class _Tp, class _Up>
struct __is_transparent<_Tp, _Up,  
                        typename __void_t<typename _Tp::is_transparent>::type>
   : std::true_type {};
#endif



template <class _From, class _To>
struct __rebind_pointer {
#ifndef _LIBCPP_CXX03_LANG
    typedef typename std::pointer_traits<_From>::template rebind<_To>        type;
#else
    typedef typename pointer_traits<_From>::template rebind<_To>::other type;
#endif
};

template <class _Traits, class _Tp>
struct __rebind_alloc_helper
{
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Traits::template rebind_alloc<_Tp>        type;
#else
    typedef typename _Traits::template rebind_alloc<_Tp>::other type;
#endif
};

template <class _Arg1, class _Arg2, class _Result>
struct _LIBCPP_TEMPLATE_VIS binary_function
{
    typedef _Arg1   first_argument_type;
    typedef _Arg2   second_argument_type;
    typedef _Result result_type;
};


} // namespace nodecpp

_LIBCPP_POP_MACROS

#endif  // _LIBCPP___TREE
