Running and adding automated tests
==================================

See file [CHECKER-QUICK-START.md](CHECKER-QUICK-START.md) for a very first, very quick sample use.

This document covers automated tests runned by `llvm-lit.py`. This is a llvm/clang automated testing tool.


Important points
----------------

You can run automated tests only if you built the tools from source code, since the test runner has dependencies with the build system.

On Windows, you may need to run test scripts from within a __x64 Native Tools Command Prompt for VS 2017__ otherwise your samples can reach standard library includes.


Scripts
-------

If you look at `test.sh` (or `test.bat` under Windows), it is simple:

	#!/bin/sh

	PATH=$PWD/3rdparty/llvm/utils/lit:$PATH
	PATH=$PWD/build/release/bin:$PATH

	llvm-lit test

Sets the `PATH` and runs the tool over the `test` folder. The `test` folder has some special files `test/lit.cfg` and `test/lit.site.cfg.in` used to configure lit, and also `test/CMakeLists.txt` has some special content used by `cmake` during build configuration to properly set up the test environment.

Each `.cpp` in that folder is considered a test case. To add a new test case, simple add a new `.cpp` file under `test/library` (or `test/checker`) and `llvm-lit` will automatically pick it up. 

Important is to notice that automated tests under folder `test/checker` don't access the __std__ library on the system, nor the real `safe_ptr.h` library, they use a small _mock_ of them found in `Inputs` folders. This is done such way to have tests self contained and improve test stability. Tests under `test/library` do use real `safe_ptr.h` library and real __std__ on the platform.


Each `.cpp` file has a header line, that tells the runner how to run this particular test. In our case, they are all the same:

	// RUN: safememory-checker %s | FileCheck %s -implicit-check-not="{{warning|error}}:"


What is after the `RUN:` is more or less equivalent to a command line, `%s` will be replaced by the file name, and the pipe `|` is like a normal shell script pipe.
Then `FileCheck` is an utility that will try to match its __stdin__ (that is the __stdout__ of `safememory-checker`) with the lines prefixed by `CHECK:` in the same source code. i.e.:

	// CHECK: :[[@LINE-1]]:12: warning: (S1.3)

Here `[[@LINE-1]]` will be replaced by the line number minus one, and the rest is part of the error message. We don't need to match the full error message, partial matches are allowed.

We also add `-implicit-check-not` on the `RUN:` directive so every `warning` or `error` line __MUST__ match with a `CHECK:` in the file.
There must be a one to one relationship between every error (or warning) messages generated by `safememory-checker` and the `CHECK:` lines in the file.


For more information on `llvm-lit.py` pleasee see https://llvm.org/docs/CommandGuide/lit.html


Also important to notice is that `safememory-checker` will automatically pick `safe_library.json` and `compile_flags.txt` from the source folder.

To add a new folder under `test` you need to copy file `safe_library.json` and `compile_flags.txt`, and maybe modify then to suit your needs.

Please see [CHECKER-RUN.md](CHECKER-RUN.md) to better understand how those files fit inside the process and when you may need to modify them.




