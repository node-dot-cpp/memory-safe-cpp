diff --git a/include/clang/AST/Expr.h b/include/clang/AST/Expr.h
index d44a815c86..a4b72fd99b 100644
--- a/include/clang/AST/Expr.h
+++ b/include/clang/AST/Expr.h
@@ -1348,6 +1348,38 @@ public:
     return DeclRefExprBits.RefersToEnclosingVariableOrCapture;
   }
 
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that has explicit dezombified.
+  void setDezombiefyAlreadyPresent() {
+    DeclRefExprBits.DezombifyFlags = DezombifyAlreadyPresent;
+  }
+
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that may need to be dezombified.
+  void setDezombiefyCandidate() {
+    DeclRefExprBits.DezombifyFlags = DezombifyCandidate;
+  }
+
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that may need to be dezombified,
+  /// but a deeper flow analysis prove dezombified not really needed.
+  void setDezombiefyCandidateButRelaxed() {
+    DeclRefExprBits.DezombifyFlags = DezombifyCandidateButRelaxed;
+  }
+
+  /// Does this DeclRefExpr refer to a varialbe that may
+  /// need to be dezombified after all analysis stages.
+  bool isDezombiefyCandidateOrRelaxed() const {
+    return DeclRefExprBits.DezombifyFlags == DezombifyCandidate ||
+      DeclRefExprBits.DezombifyFlags == DezombifyCandidateButRelaxed;
+  }
+
+  /// Does this DeclRefExpr refer to a varialbe that really
+  /// needs to be dezombified after all analysis stages.
+  bool needsDezombiefyInstrumentation() const {
+    return DeclRefExprBits.DezombifyFlags == DezombifyCandidate;
+  }
+
   static bool classof(const Stmt *T) {
     return T->getStmtClass() == DeclRefExprClass;
   }
diff --git a/include/clang/AST/ExprCXX.h b/include/clang/AST/ExprCXX.h
index faddbc6d96..c8a47fb7ab 100644
--- a/include/clang/AST/ExprCXX.h
+++ b/include/clang/AST/ExprCXX.h
@@ -1013,6 +1013,7 @@ public:
              Ty->isInstantiationDependentType(),
              /*ContainsUnexpandedParameterPack=*/false) {
     CXXThisExprBits.IsImplicit = IsImplicit;
+    CXXThisExprBits.DezombiefyFlags = 0;
     CXXThisExprBits.Loc = L;
   }
 
@@ -1027,6 +1028,38 @@ public:
   bool isImplicit() const { return CXXThisExprBits.IsImplicit; }
   void setImplicit(bool I) { CXXThisExprBits.IsImplicit = I; }
 
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that has explicit dezombified.
+  void setDezombiefyAlreadyPresent() {
+    CXXThisExprBits.DezombiefyFlags = DezombifyAlreadyPresent;
+  }
+
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that may need to be dezombified.
+  void setDezombiefyCandidate() {
+    CXXThisExprBits.DezombiefyFlags = DezombifyCandidate;
+  }
+
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that may need to be dezombified,
+  /// but a deeper flow analysis prove dezombified not really needed.
+  void setDezombiefyCandidateButRelaxed() {
+    CXXThisExprBits.DezombiefyFlags = DezombifyCandidateButRelaxed;
+  }
+
+  /// Does this DeclRefExpr refer to a varialbe that may
+  /// need to be dezombified after all analysis stages.
+  bool isDezombiefyCandidateOrRelaxed() const {
+    return CXXThisExprBits.DezombiefyFlags == DezombifyCandidate ||
+      CXXThisExprBits.DezombiefyFlags == DezombifyCandidateButRelaxed;
+  }
+
+  /// Does this DeclRefExpr refer to a varialbe that really
+  /// needs to be dezombified after all analysis stages.
+  bool needsDezombiefyInstrumentation() const {
+    return CXXThisExprBits.DezombiefyFlags == DezombifyCandidate;
+  }
+
   static bool classof(const Stmt *T) {
     return T->getStmtClass() == CXXThisExprClass;
   }
diff --git a/include/clang/AST/Stmt.h b/include/clang/AST/Stmt.h
index 403b88ac3a..083bd6ab29 100644
--- a/include/clang/AST/Stmt.h
+++ b/include/clang/AST/Stmt.h
@@ -367,6 +367,13 @@ protected:
     SourceLocation Loc;
   };
 
+  enum DREDezombifyFlags {
+    NoDezombify = 0,
+    DezombifyAlreadyPresent,
+    DezombifyCandidate,
+    DezombifyCandidateButRelaxed
+  };
+
   class DeclRefExprBitfields {
     friend class ASTStmtReader; // deserialization
     friend class DeclRefExpr;
@@ -379,6 +386,7 @@ protected:
     unsigned HadMultipleCandidates : 1;
     unsigned RefersToEnclosingVariableOrCapture : 1;
     unsigned NonOdrUseReason : 2;
+    unsigned DezombifyFlags : 2;
 
     /// The location of the declaration name itself.
     SourceLocation Loc;
@@ -632,6 +640,7 @@ protected:
 
     /// Whether this is an implicit "this".
     unsigned IsImplicit : 1;
+	unsigned DezombiefyFlags :2;
 
     /// The location of the "this".
     SourceLocation Loc;
diff --git a/include/clang/ASTMatchers/ASTMatchers.h b/include/clang/ASTMatchers/ASTMatchers.h
index 063d8217d9..aea85dd486 100644
--- a/include/clang/ASTMatchers/ASTMatchers.h
+++ b/include/clang/ASTMatchers/ASTMatchers.h
@@ -6694,6 +6694,18 @@ AST_MATCHER_P(OMPExecutableDirective, isAllowedToContainClauseKind,
 // End OpenMP handling.
 //----------------------------------------------------------------------------//
 
+
+/// Matches coroutine body  statements.
+extern const internal::VariadicDynCastAllOfMatcher<Stmt, CoroutineBodyStmt>
+    coroutineBodyStmt;
+
+/// Matches a coroutine that has a given body.
+AST_MATCHER_P(CoroutineBodyStmt, hasCoroutineBody, internal::Matcher<Stmt>, InnerMatcher) {
+  const Stmt *const Statement = internal::GetBodyMatcher<CoroutineBodyStmt>::get(Node);
+  return (Statement != nullptr &&
+          InnerMatcher.matches(*Statement, Finder, Builder));
+}
+
 } // namespace ast_matchers
 } // namespace clang
 
diff --git a/include/clang/Basic/Attr.td b/include/clang/Basic/Attr.td
index d39b16e62b..d49c24b032 100644
--- a/include/clang/Basic/Attr.td
+++ b/include/clang/Basic/Attr.td
@@ -3274,3 +3274,63 @@ def ObjCExternallyRetained : InheritableAttr {
   let Subjects = SubjectList<[NonParmVar, Function, Block, ObjCMethod]>;
   let Documentation = [ObjCExternallyRetainedDocs];
 }
+
+def NodeCppNakedStruct : Attr {
+  let Spellings = [CXX11<"nodecpp","naked_struct">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [NodeCppNakedStructDocs];
+}
+
+def NodeCppMayExtend : Attr {
+  let Spellings = [CXX11<"nodecpp","may_extend_to_this">];
+//  let Subjects = SubjectList<[ParmVar]>;
+  let Documentation = [NodeCppMayExtendDocs];
+}
+
+def NodeCppNoAwait : Attr {
+  let Spellings = [CXX11<"nodecpp","no_await">];
+//  let Subjects = SubjectList<[ParmVar]>;
+  let Documentation = [NodeCppNoAwaitDocs];
+}
+
+def NodeCppMemoryUnsafe : Attr {
+  let Spellings = [CXX11<"nodecpp","memory_unsafe">];
+//  let Subjects = SubjectList<[Namespace]>;
+  let Documentation = [NodeCppMemoryUnsafeDocs];
+}
+
+def NodeCppNonDeterministic : Attr {
+  let Spellings = [CXX11<"nodecpp","non_deterministic">];
+//  let Subjects = SubjectList<[Namespace]>;
+  let Documentation = [NodeCppNonDeterministicDocs];
+}
+
+def NodeCppNoSideEffect : Attr {
+  let Spellings = [CXX11<"nodecpp","no_side_effect">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [NodeCppNoSideEffectDocs];
+}
+
+def NodeCppNoSideEffectWhenConst : Attr {
+  let Spellings = [CXX11<"nodecpp","no_side_effect_when_const">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [NodeCppNoSideEffectWhenConstDocs];
+}
+
+def NodeCppDeepConst : Attr {
+  let Spellings = [CXX11<"nodecpp","deep_const">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [NodeCppDeepConstDocs];
+}
+
+def NodeCppDeepConstWhenParams : Attr {
+  let Spellings = [CXX11<"nodecpp","deep_const_when_params">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [NodeCppDeepConstWhenParamsDocs];
+}
+
+def NodeCppAwaitable : Attr {
+  let Spellings = [CXX11<"nodecpp","awaitable">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [NodeCppAwaitableDocs];
+}
diff --git a/include/clang/Basic/AttrDocs.td b/include/clang/Basic/AttrDocs.td
index fac6116057..3a83e7c6fc 100644
--- a/include/clang/Basic/AttrDocs.td
+++ b/include/clang/Basic/AttrDocs.td
@@ -4194,4 +4194,94 @@ be accessed on both device side and host side. It has external linkage and is
 not initialized on device side. It has internal linkage and is initialized by
 the initializer on host side.
   }];
-}
\ No newline at end of file
+}
+
+def DocCatNodeCpp : DocumentationCategory<"Node-dot-cpp specifics"> {
+  let Content = [{
+Node-dot-cpp specific attributes
+  }];
+}
+
+
+def NodeCppNakedStructDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on class / struct declaration.
+Such classes can be created only on the stack and may contain naked ptrs.
+}];
+}
+
+def NodeCppMayExtendDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on library parameter declaration to indicate that lifetime
+of the callable object may be extended beyond the time of the call.
+Checker will check that no reference to stack object is present in such arguments.
+}];
+}
+
+def NodeCppNoAwaitDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on library method declaration to indicate that returned
+awaitable doesn't need to be checked for co_await.
+}];
+}
+
+def NodeCppMemoryUnsafeDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on namespace declaration to indicate that
+elements inside such namespace shouln't be checked for memory safety.
+}];
+}
+
+def NodeCppNonDeterministicDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on namespace declaration to indicate that
+elements inside such namespace shouln't be checked for determinism.
+}];
+}
+
+
+def NodeCppNoSideEffectDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on function and method declaration to indicate
+it is side effect free.
+}];
+}
+
+def NodeCppNoSideEffectWhenConstDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on class declaration to indicate that all const
+methods are [[no_side_effect]]
+}];
+}
+
+def NodeCppDeepConstDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on class declaration to indicate that a `const`
+instance of this type is completely immutable.
+}];
+}
+
+def NodeCppDeepConstWhenParamsDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on class template declaration to indicate that
+when all type parameters are [[deep_const]] then such instantiation is also
+[[deep_const]].
+}];
+}
+
+def NodeCppAwaitableDocs : Documentation {
+  let Category = DocCatNodeCpp;
+  let Content = [{
+This attribute is used on class declaration to indicate that is an awaitable
+type and therefore it must be verified by that co_await is called on instances.
+}];
+}
diff --git a/include/clang/Basic/DiagnosticSemaKinds.td b/include/clang/Basic/DiagnosticSemaKinds.td
index 275c4e4365..28b5f46940 100644
--- a/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/include/clang/Basic/DiagnosticSemaKinds.td
@@ -9759,4 +9759,7 @@ def err_bit_cast_non_trivially_copyable : Error<
   "__builtin_bit_cast %select{source|destination}0 type must be trivially copyable">;
 def err_bit_cast_type_size_mismatch : Error<
   "__builtin_bit_cast source size does not equal destination size (%0 vs %1)">;
+
+def err_unknown_nodecpp_attribute : Error<
+  "(C1) unknown attribute %0">;
 } // end of sema component.
diff --git a/lib/AST/Expr.cpp b/lib/AST/Expr.cpp
index 6ef77b8aee..50c47a3c6b 100644
--- a/lib/AST/Expr.cpp
+++ b/lib/AST/Expr.cpp
@@ -482,6 +482,7 @@ DeclRefExpr::DeclRefExpr(const ASTContext &Ctx, ValueDecl *D,
   DeclRefExprBits.RefersToEnclosingVariableOrCapture =
       RefersToEnclosingVariableOrCapture;
   DeclRefExprBits.NonOdrUseReason = NOUR;
+  DeclRefExprBits.DezombifyFlags = 0;
   DeclRefExprBits.Loc = L;
   computeDependence(Ctx);
 }
@@ -529,6 +530,7 @@ DeclRefExpr::DeclRefExpr(const ASTContext &Ctx,
         TemplateKWLoc);
   }
   DeclRefExprBits.HadMultipleCandidates = 0;
+  DeclRefExprBits.DezombifyFlags = 0;
 
   computeDependence(Ctx);
 }
diff --git a/lib/ASTMatchers/ASTMatchFinder.cpp b/lib/ASTMatchers/ASTMatchFinder.cpp
index f407e0875a..f081ce09e1 100644
--- a/lib/ASTMatchers/ASTMatchFinder.cpp
+++ b/lib/ASTMatchers/ASTMatchFinder.cpp
@@ -381,6 +381,7 @@ public:
   bool TraverseNestedNameSpecifier(NestedNameSpecifier *NNS);
   bool TraverseNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS);
   bool TraverseConstructorInitializer(CXXCtorInitializer *CtorInit);
+  bool TraverseCoroutineBodyStmt(CoroutineBodyStmt *CoroBody);
 
   // Matches children or descendants of 'Node' with 'BaseMatcher'.
   bool memoizedMatchesRecursively(const ast_type_traits::DynTypedNode &Node,
@@ -852,6 +853,24 @@ bool MatchASTVisitor::TraverseDecl(Decl *DeclNode) {
   if (!DeclNode) {
     return true;
   }
+
+  //mb: we don't traverse decls in system-headers
+  // nor namespaces with [[nodecpp::memory_unsafe]] attr
+  if(DeclNode->hasAttr<NodeCppMemoryUnsafeAttr>()) {
+    return true;
+  }
+  else if (!isa<TranslationUnitDecl>(DeclNode)) {
+
+    auto &SourceManager = getASTContext().getSourceManager();
+    auto ExpansionLoc = SourceManager.getExpansionLoc(DeclNode->getLocation());
+    if (ExpansionLoc.isInvalid()) {
+      return true;
+    }
+    if (SourceManager.isInSystemHeader(ExpansionLoc)) {
+      return true;
+    }
+  }
+
   match(*DeclNode);
   return RecursiveASTVisitor<MatchASTVisitor>::TraverseDecl(DeclNode);
 }
@@ -911,6 +930,16 @@ bool MatchASTVisitor::TraverseConstructorInitializer(
       CtorInit);
 }
 
+bool MatchASTVisitor::TraverseCoroutineBodyStmt(CoroutineBodyStmt *CoroBody) {
+  if (!CoroBody)
+    return true;
+
+  match(*CoroBody);
+
+  //mb:don't go into automatic coro stuff, only traverse the body
+  return RecursiveASTVisitor<MatchASTVisitor>::TraverseStmt(CoroBody->getBody());
+}
+
 class MatchASTConsumer : public ASTConsumer {
 public:
   MatchASTConsumer(MatchFinder *Finder,
diff --git a/lib/ASTMatchers/ASTMatchersInternal.cpp b/lib/ASTMatchers/ASTMatchersInternal.cpp
index 4ee32fbe94..e88e287c7b 100644
--- a/lib/ASTMatchers/ASTMatchersInternal.cpp
+++ b/lib/ASTMatchers/ASTMatchersInternal.cpp
@@ -852,5 +852,7 @@ const internal::VariadicDynCastAllOfMatcher<OMPClause, OMPDefaultClause>
 const internal::VariadicDynCastAllOfMatcher<Decl, CXXDeductionGuideDecl>
     cxxDeductionGuideDecl;
 
+const internal::VariadicDynCastAllOfMatcher<Stmt, CoroutineBodyStmt> coroutineBodyStmt;
+
 } // end namespace ast_matchers
 } // end namespace clang
diff --git a/lib/ASTMatchers/Dynamic/Registry.cpp b/lib/ASTMatchers/Dynamic/Registry.cpp
index 3305805357..800db9b2d6 100644
--- a/lib/ASTMatchers/Dynamic/Registry.cpp
+++ b/lib/ASTMatchers/Dynamic/Registry.cpp
@@ -522,6 +522,9 @@ RegistryMaps::RegistryMaps() {
   REGISTER_MATCHER(voidType);
   REGISTER_MATCHER(whileStmt);
   REGISTER_MATCHER(withInitializer);
+
+  REGISTER_MATCHER(coroutineBodyStmt);
+  REGISTER_MATCHER(hasCoroutineBody);
 }
 
 RegistryMaps::~RegistryMaps() = default;
diff --git a/lib/Frontend/InitHeaderSearch.cpp b/lib/Frontend/InitHeaderSearch.cpp
index d65d13489d..9d4fefe9fc 100644
--- a/lib/Frontend/InitHeaderSearch.cpp
+++ b/lib/Frontend/InitHeaderSearch.cpp
@@ -447,6 +447,12 @@ void InitHeaderSearch::AddDefaultIncludePaths(const LangOptions &Lang,
   if (Lang.CPlusPlus && !Lang.AsmPreprocessor &&
       HSOpts.UseStandardCXXIncludes && HSOpts.UseStandardSystemIncludes) {
     if (HSOpts.UseLibcxx) {
+      if (triple.isOSDarwin()) {
+        if(!HasSysroot) {
+            AddUnmappedPath("/Library/Developer/CommandLineTools/usr/include/c++/v1", CXXSystem, false);
+            AddUnmappedPath("/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include", CXXSystem, false);
+        }
+      }
       AddPath("/usr/include/c++/v1", CXXSystem, false);
     } else {
       AddDefaultCPlusPlusIncludePaths(Lang, triple, HSOpts);
diff --git a/lib/Rewrite/HTMLRewrite.cpp b/lib/Rewrite/HTMLRewrite.cpp
index e304fbbed7..c961659de7 100644
--- a/lib/Rewrite/HTMLRewrite.cpp
+++ b/lib/Rewrite/HTMLRewrite.cpp
@@ -347,7 +347,7 @@ h1 { font-size:14pt }
 }
 .macro { color: DarkMagenta; }
 
-#tooltiphint {
+" R"#tooltiphint {
   position: fixed;
   width: 50em;
   margin-left: -25em;
diff --git a/lib/Sema/SemaDeclAttr.cpp b/lib/Sema/SemaDeclAttr.cpp
index ee06f8ae51..48743f9d19 100644
--- a/lib/Sema/SemaDeclAttr.cpp
+++ b/lib/Sema/SemaDeclAttr.cpp
@@ -6616,11 +6616,17 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   // though they were unknown attributes.
   if (AL.getKind() == ParsedAttr::UnknownAttribute ||
       !AL.existsInTarget(S.Context.getTargetInfo())) {
-    S.Diag(AL.getLoc(),
-           AL.isDeclspecAttribute()
-               ? (unsigned)diag::warn_unhandled_ms_attribute_ignored
-               : (unsigned)diag::warn_unknown_attribute_ignored)
-        << AL;
+
+    if(AL.hasScope() && AL.getScopeName()->getName() == "nodecpp") {
+      S.Diag(AL.getLoc(), diag::err_unknown_nodecpp_attribute) << AL.getName();
+    }
+    else {
+	    S.Diag(AL.getLoc(),
+	           AL.isDeclspecAttribute()
+	               ? (unsigned)diag::warn_unhandled_ms_attribute_ignored
+	               : (unsigned)diag::warn_unknown_attribute_ignored)
+	        << AL;
+    }
     return;
   }
 
@@ -7340,6 +7346,37 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
 
   case ParsedAttr::AT_MSAllocator:
     handleMSAllocatorAttr(S, D, AL);
+	break;
+
+  case ParsedAttr::AT_NodeCppNakedStruct:
+    handleSimpleAttribute<NodeCppNakedStructAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppMayExtend:
+    handleSimpleAttribute<NodeCppMayExtendAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppNoAwait:
+    handleSimpleAttribute<NodeCppNoAwaitAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppMemoryUnsafe:
+    handleSimpleAttribute<NodeCppMemoryUnsafeAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppNonDeterministic:
+    handleSimpleAttribute<NodeCppNonDeterministicAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppNoSideEffect:
+    handleSimpleAttribute<NodeCppNoSideEffectAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppNoSideEffectWhenConst:
+    handleSimpleAttribute<NodeCppNoSideEffectWhenConstAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppDeepConst:
+    handleSimpleAttribute<NodeCppDeepConstAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppDeepConstWhenParams:
+    handleSimpleAttribute<NodeCppDeepConstWhenParamsAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppAwaitable:
+    handleSimpleAttribute<NodeCppAwaitableAttr>(S, D, AL);
     break;
   }
 }
diff --git a/lib/Sema/SemaDeclCXX.cpp b/lib/Sema/SemaDeclCXX.cpp
index 2f9e4f961f..7b02e48b76 100644
--- a/lib/Sema/SemaDeclCXX.cpp
+++ b/lib/Sema/SemaDeclCXX.cpp
@@ -14829,8 +14829,8 @@ bool Sema::CheckOverridingFunctionAttributes(const CXXMethodDecl *New,
   const auto *NewFT = New->getType()->getAs<FunctionProtoType>();
   const auto *OldFT = Old->getType()->getAs<FunctionProtoType>();
 
-  if (OldFT->hasExtParameterInfos()) {
-    for (unsigned I = 0, E = OldFT->getNumParams(); I != E; ++I)
+  if (OldFT->hasExtParameterInfos() || NewFT->hasExtParameterInfos()) {
+    for (unsigned I = 0, E = OldFT->getNumParams(); I != E; ++I) {
       // A parameter of the overriding method should be annotated with noescape
       // if the corresponding parameter of the overridden method is annotated.
       if (OldFT->getExtParameterInfo(I).isNoEscape() &&
@@ -14840,6 +14840,7 @@ bool Sema::CheckOverridingFunctionAttributes(const CXXMethodDecl *New,
         Diag(Old->getParamDecl(I)->getLocation(),
              diag::note_overridden_marked_noescape);
       }
+    }
   }
 
   // Virtual overrides must have the same code_seg.
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 223f1f74f3..12be23a25f 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -39,3 +39,6 @@ add_llvm_external_project(clang-tools-extra extra)
 
 # libclang may require clang-tidy in clang-tools-extra.
 add_clang_subdirectory(libclang)
+
+# Add nodecpp here, because using LLVM_EXTERNAL_PROJECTS don't seem to work
+add_llvm_external_project(checker)
