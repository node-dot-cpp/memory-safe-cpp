diff --git a/include/clang/AST/Expr.h b/include/clang/AST/Expr.h
index d44a815c..a4b72fd9 100644
--- a/include/clang/AST/Expr.h
+++ b/include/clang/AST/Expr.h
@@ -1348,6 +1348,38 @@ public:
     return DeclRefExprBits.RefersToEnclosingVariableOrCapture;
   }
 
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that has explicit dezombified.
+  void setDezombiefyAlreadyPresent() {
+    DeclRefExprBits.DezombifyFlags = DezombifyAlreadyPresent;
+  }
+
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that may need to be dezombified.
+  void setDezombiefyCandidate() {
+    DeclRefExprBits.DezombifyFlags = DezombifyCandidate;
+  }
+
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that may need to be dezombified,
+  /// but a deeper flow analysis prove dezombified not really needed.
+  void setDezombiefyCandidateButRelaxed() {
+    DeclRefExprBits.DezombifyFlags = DezombifyCandidateButRelaxed;
+  }
+
+  /// Does this DeclRefExpr refer to a varialbe that may
+  /// need to be dezombified after all analysis stages.
+  bool isDezombiefyCandidateOrRelaxed() const {
+    return DeclRefExprBits.DezombifyFlags == DezombifyCandidate ||
+      DeclRefExprBits.DezombifyFlags == DezombifyCandidateButRelaxed;
+  }
+
+  /// Does this DeclRefExpr refer to a varialbe that really
+  /// needs to be dezombified after all analysis stages.
+  bool needsDezombiefyInstrumentation() const {
+    return DeclRefExprBits.DezombifyFlags == DezombifyCandidate;
+  }
+
   static bool classof(const Stmt *T) {
     return T->getStmtClass() == DeclRefExprClass;
   }
diff --git a/include/clang/AST/ExprCXX.h b/include/clang/AST/ExprCXX.h
index faddbc6d..c8a47fb7 100644
--- a/include/clang/AST/ExprCXX.h
+++ b/include/clang/AST/ExprCXX.h
@@ -1013,6 +1013,7 @@ public:
              Ty->isInstantiationDependentType(),
              /*ContainsUnexpandedParameterPack=*/false) {
     CXXThisExprBits.IsImplicit = IsImplicit;
+    CXXThisExprBits.DezombiefyFlags = 0;
     CXXThisExprBits.Loc = L;
   }
 
@@ -1027,6 +1028,38 @@ public:
   bool isImplicit() const { return CXXThisExprBits.IsImplicit; }
   void setImplicit(bool I) { CXXThisExprBits.IsImplicit = I; }
 
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that has explicit dezombified.
+  void setDezombiefyAlreadyPresent() {
+    CXXThisExprBits.DezombiefyFlags = DezombifyAlreadyPresent;
+  }
+
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that may need to be dezombified.
+  void setDezombiefyCandidate() {
+    CXXThisExprBits.DezombiefyFlags = DezombifyCandidate;
+  }
+
+  /// Sets the flag telling whether this expression refers to
+  /// a variable of a type that may need to be dezombified,
+  /// but a deeper flow analysis prove dezombified not really needed.
+  void setDezombiefyCandidateButRelaxed() {
+    CXXThisExprBits.DezombiefyFlags = DezombifyCandidateButRelaxed;
+  }
+
+  /// Does this DeclRefExpr refer to a varialbe that may
+  /// need to be dezombified after all analysis stages.
+  bool isDezombiefyCandidateOrRelaxed() const {
+    return CXXThisExprBits.DezombiefyFlags == DezombifyCandidate ||
+      CXXThisExprBits.DezombiefyFlags == DezombifyCandidateButRelaxed;
+  }
+
+  /// Does this DeclRefExpr refer to a varialbe that really
+  /// needs to be dezombified after all analysis stages.
+  bool needsDezombiefyInstrumentation() const {
+    return CXXThisExprBits.DezombiefyFlags == DezombifyCandidate;
+  }
+
   static bool classof(const Stmt *T) {
     return T->getStmtClass() == CXXThisExprClass;
   }
diff --git a/include/clang/AST/Stmt.h b/include/clang/AST/Stmt.h
index 403b88ac..083bd6ab 100644
--- a/include/clang/AST/Stmt.h
+++ b/include/clang/AST/Stmt.h
@@ -367,6 +367,13 @@ protected:
     SourceLocation Loc;
   };
 
+  enum DREDezombifyFlags {
+    NoDezombify = 0,
+    DezombifyAlreadyPresent,
+    DezombifyCandidate,
+    DezombifyCandidateButRelaxed
+  };
+
   class DeclRefExprBitfields {
     friend class ASTStmtReader; // deserialization
     friend class DeclRefExpr;
@@ -379,6 +386,7 @@ protected:
     unsigned HadMultipleCandidates : 1;
     unsigned RefersToEnclosingVariableOrCapture : 1;
     unsigned NonOdrUseReason : 2;
+    unsigned DezombifyFlags : 2;
 
     /// The location of the declaration name itself.
     SourceLocation Loc;
@@ -632,6 +640,7 @@ protected:
 
     /// Whether this is an implicit "this".
     unsigned IsImplicit : 1;
+	unsigned DezombiefyFlags :2;
 
     /// The location of the "this".
     SourceLocation Loc;
diff --git a/include/clang/ASTMatchers/ASTMatchers.h b/include/clang/ASTMatchers/ASTMatchers.h
index 063d8217..aea85dd4 100644
--- a/include/clang/ASTMatchers/ASTMatchers.h
+++ b/include/clang/ASTMatchers/ASTMatchers.h
@@ -6694,6 +6694,18 @@ AST_MATCHER_P(OMPExecutableDirective, isAllowedToContainClauseKind,
 // End OpenMP handling.
 //----------------------------------------------------------------------------//
 
+
+/// Matches coroutine body  statements.
+extern const internal::VariadicDynCastAllOfMatcher<Stmt, CoroutineBodyStmt>
+    coroutineBodyStmt;
+
+/// Matches a coroutine that has a given body.
+AST_MATCHER_P(CoroutineBodyStmt, hasCoroutineBody, internal::Matcher<Stmt>, InnerMatcher) {
+  const Stmt *const Statement = internal::GetBodyMatcher<CoroutineBodyStmt>::get(Node);
+  return (Statement != nullptr &&
+          InnerMatcher.matches(*Statement, Finder, Builder));
+}
+
 } // namespace ast_matchers
 } // namespace clang
 
diff --git a/include/clang/Basic/Attr.td b/include/clang/Basic/Attr.td
index d39b16e6..a25e5377 100644
--- a/include/clang/Basic/Attr.td
+++ b/include/clang/Basic/Attr.td
@@ -3274,3 +3274,118 @@ def ObjCExternallyRetained : InheritableAttr {
   let Subjects = SubjectList<[NonParmVar, Function, Block, ObjCMethod]>;
   let Documentation = [ObjCExternallyRetainedDocs];
 }
+
+def NodeCppNakedStruct : Attr {
+  let Spellings = [CXX11<"nodecpp","naked_struct">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [SafeMemoryNakedStructDocs];
+}
+
+def SafeMemoryNakedStruct : Attr {
+  let Spellings = [CXX11<"safe_memory","naked_struct">];
+  let Documentation = [SafeMemoryNakedStructDocs];
+}
+
+def NodeCppMayExtend : Attr {
+  let Spellings = [CXX11<"nodecpp","may_extend_to_this">];
+  let Documentation = [SafeMemoryMayExtendDocs];
+}
+
+def SafeMemoryMayExtend : Attr {
+  let Spellings = [CXX11<"safe_memory","may_extend_to_this">];
+  let Documentation = [SafeMemoryMayExtendDocs];
+}
+
+def NodeCppNoAwait : Attr {
+  let Spellings = [CXX11<"nodecpp","no_await">];
+//  let Subjects = SubjectList<[ParmVar]>;
+  let Documentation = [SafeMemoryNoAwaitDocs];
+}
+
+def SafeMemoryNoAwait : Attr {
+  let Spellings = [CXX11<"safe_memory","no_await">];
+  let Documentation = [SafeMemoryNoAwaitDocs];
+}
+
+def NodeCppMemoryUnsafe : Attr {
+  let Spellings = [CXX11<"nodecpp","memory_unsafe">];
+//  let Subjects = SubjectList<[Namespace]>;
+  let Documentation = [SafeMemoryMemoryUnsafeDocs];
+}
+
+def SafeMemoryMemoryUnsafe : Attr {
+  let Spellings = [CXX11<"safe_memory","memory_unsafe">];
+  let Documentation = [SafeMemoryMemoryUnsafeDocs];
+}
+
+def NodeCppNonDeterministic : Attr {
+  let Spellings = [CXX11<"nodecpp","non_deterministic">];
+//  let Subjects = SubjectList<[Namespace]>;
+  let Documentation = [SafeMemoryNonDeterministicDocs];
+}
+
+def SafeMemoryNonDeterministic : Attr {
+  let Spellings = [CXX11<"safe_memory","non_deterministic">];
+  let Documentation = [SafeMemoryNonDeterministicDocs];
+}
+
+def NodeCppNoSideEffect : Attr {
+  let Spellings = [CXX11<"nodecpp","no_side_effect">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [SafeMemoryNoSideEffectDocs];
+}
+
+def SafeMemoryNoSideEffect : Attr {
+  let Spellings = [CXX11<"safe_memory","no_side_effect">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [SafeMemoryNoSideEffectDocs];
+}
+
+def NodeCppNoSideEffectWhenConst : Attr {
+  let Spellings = [CXX11<"nodecpp","no_side_effect_when_const">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [SafeMemoryNoSideEffectWhenConstDocs];
+}
+
+def SafeMemoryNoSideEffectWhenConst : Attr {
+  let Spellings = [CXX11<"safe_memory","no_side_effect_when_const">];
+  let Documentation = [SafeMemoryNoSideEffectWhenConstDocs];
+}
+
+def NodeCppDeepConst : Attr {
+  let Spellings = [CXX11<"nodecpp","deep_const">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [SafeMemoryDeepConstDocs];
+}
+
+def SafeMemoryDeepConst : Attr {
+  let Spellings = [CXX11<"safe_memory","deep_const">];
+  let Documentation = [SafeMemoryDeepConstDocs];
+}
+
+def NodeCppDeepConstWhenParams : Attr {
+  let Spellings = [CXX11<"nodecpp","deep_const_when_params">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [SafeMemoryDeepConstWhenParamsDocs];
+}
+
+def SafeMemoryDeepConstWhenParams : Attr {
+  let Spellings = [CXX11<"safe_memory","deep_const_when_params">];
+  let Documentation = [SafeMemoryDeepConstWhenParamsDocs];
+}
+
+def NodeCppAwaitable : Attr {
+  let Spellings = [CXX11<"nodecpp","awaitable">];
+//  let Subjects = SubjectList<[CXXRecord]>;
+  let Documentation = [SafeMemoryAwaitableDocs];
+}
+
+def SafeMemoryAwaitable : Attr {
+  let Spellings = [CXX11<"safe_memory","awaitable">];
+  let Documentation = [SafeMemoryAwaitableDocs];
+}
+
+def SafeMemoryCheckAsUserCode : Attr {
+  let Spellings = [CXX11<"safe_memory","check_at_instantiation">];
+  let Documentation = [SafeMemoryCheckAsUserCodeDocs];
+}
diff --git a/include/clang/Basic/AttrDocs.td b/include/clang/Basic/AttrDocs.td
index fac61160..270b29bc 100644
--- a/include/clang/Basic/AttrDocs.td
+++ b/include/clang/Basic/AttrDocs.td
@@ -4194,4 +4194,107 @@ be accessed on both device side and host side. It has external linkage and is
 not initialized on device side. It has internal linkage and is initialized by
 the initializer on host side.
   }];
-}
\ No newline at end of file
+}
+
+def DocCatSafeMemory : DocumentationCategory<"safe_memory specifics"> {
+  let Content = [{
+Attributes specifics to ``safe_memory`` checker tools and libraries.
+  }];
+}
+
+
+def SafeMemoryNakedStructDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on class / struct declaration.
+Such classes can be created only on the stack and may contain naked ptrs.
+}];
+}
+
+def SafeMemoryMayExtendDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on library parameter declaration to indicate that lifetime
+of the callable object may be extended beyond the time of the call.
+Checker will check that no reference to stack object is present in such arguments.
+}];
+}
+
+def SafeMemoryNoAwaitDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on library method declaration to indicate that returned
+awaitable doesn't need to be checked for co_await.
+}];
+}
+
+def SafeMemoryMemoryUnsafeDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on namespace declaration to indicate that
+elements inside such namespace shouln't be checked for memory safety.
+}];
+}
+
+def SafeMemoryNonDeterministicDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on namespace declaration to indicate that
+elements inside such namespace shouln't be checked for determinism.
+}];
+}
+
+
+def SafeMemoryNoSideEffectDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on function and method declaration to indicate
+it is side effect free.
+}];
+}
+
+def SafeMemoryNoSideEffectWhenConstDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on class declaration to indicate that all const
+methods are [[no_side_effect]]
+}];
+}
+
+def SafeMemoryDeepConstDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on class declaration to indicate that a `const`
+instance of this type is completely immutable.
+}];
+}
+
+def SafeMemoryDeepConstWhenParamsDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on class template declaration to indicate that
+when all type parameters are [[deep_const]] then such instantiation is also
+[[deep_const]].
+}];
+}
+
+def SafeMemoryAwaitableDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on class declaration to indicate that is an awaitable
+type and therefore it must be verified by that co_await is called on instances.
+}];
+}
+
+def SafeMemoryCheckAsUserCodeDocs : Documentation {
+  let Category = DocCatSafeMemory;
+  let Content = [{
+This attribute is used on namespaces declared inside library code,
+and indicates checker that it should be checked as if is user code.
+Is used when library code calls back into user provided template
+parameter types, and because of that check must be made after specific
+template parameter instantiation.
+}];
+}
+
+
diff --git a/include/clang/Basic/DiagnosticSemaKinds.td b/include/clang/Basic/DiagnosticSemaKinds.td
index 275c4e43..c3bf66f0 100644
--- a/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/include/clang/Basic/DiagnosticSemaKinds.td
@@ -9759,4 +9759,7 @@ def err_bit_cast_non_trivially_copyable : Error<
   "__builtin_bit_cast %select{source|destination}0 type must be trivially copyable">;
 def err_bit_cast_type_size_mismatch : Error<
   "__builtin_bit_cast source size does not equal destination size (%0 vs %1)">;
+
+def err_unknown_safe_memory_attribute : Error<
+  "(C1) unknown attribute %0">;
 } // end of sema component.
diff --git a/lib/AST/Expr.cpp b/lib/AST/Expr.cpp
index 6ef77b8a..50c47a3c 100644
--- a/lib/AST/Expr.cpp
+++ b/lib/AST/Expr.cpp
@@ -482,6 +482,7 @@ DeclRefExpr::DeclRefExpr(const ASTContext &Ctx, ValueDecl *D,
   DeclRefExprBits.RefersToEnclosingVariableOrCapture =
       RefersToEnclosingVariableOrCapture;
   DeclRefExprBits.NonOdrUseReason = NOUR;
+  DeclRefExprBits.DezombifyFlags = 0;
   DeclRefExprBits.Loc = L;
   computeDependence(Ctx);
 }
@@ -529,6 +530,7 @@ DeclRefExpr::DeclRefExpr(const ASTContext &Ctx,
         TemplateKWLoc);
   }
   DeclRefExprBits.HadMultipleCandidates = 0;
+  DeclRefExprBits.DezombifyFlags = 0;
 
   computeDependence(Ctx);
 }
diff --git a/lib/ASTMatchers/ASTMatchFinder.cpp b/lib/ASTMatchers/ASTMatchFinder.cpp
index f407e087..efa2793b 100644
--- a/lib/ASTMatchers/ASTMatchFinder.cpp
+++ b/lib/ASTMatchers/ASTMatchFinder.cpp
@@ -381,6 +381,7 @@ public:
   bool TraverseNestedNameSpecifier(NestedNameSpecifier *NNS);
   bool TraverseNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS);
   bool TraverseConstructorInitializer(CXXCtorInitializer *CtorInit);
+  bool TraverseCoroutineBodyStmt(CoroutineBodyStmt *CoroBody);
 
   // Matches children or descendants of 'Node' with 'BaseMatcher'.
   bool memoizedMatchesRecursively(const ast_type_traits::DynTypedNode &Node,
@@ -852,6 +853,24 @@ bool MatchASTVisitor::TraverseDecl(Decl *DeclNode) {
   if (!DeclNode) {
     return true;
   }
+
+  //mb: we don't traverse decls in system-headers
+  // nor namespaces with [[nodecpp::memory_unsafe]] attr
+  if(DeclNode->hasAttr<NodeCppMemoryUnsafeAttr>() || DeclNode->hasAttr<SafeMemoryMemoryUnsafeAttr>()) {
+    return true;
+  }
+  else if (!isa<TranslationUnitDecl>(DeclNode)) {
+
+    auto &SourceManager = getASTContext().getSourceManager();
+    auto ExpansionLoc = SourceManager.getExpansionLoc(DeclNode->getLocation());
+    if (ExpansionLoc.isInvalid()) {
+      return true;
+    }
+    if (SourceManager.isInSystemHeader(ExpansionLoc)) {
+      return true;
+    }
+  }
+
   match(*DeclNode);
   return RecursiveASTVisitor<MatchASTVisitor>::TraverseDecl(DeclNode);
 }
@@ -911,6 +930,16 @@ bool MatchASTVisitor::TraverseConstructorInitializer(
       CtorInit);
 }
 
+bool MatchASTVisitor::TraverseCoroutineBodyStmt(CoroutineBodyStmt *CoroBody) {
+  if (!CoroBody)
+    return true;
+
+  match(*CoroBody);
+
+  //mb:don't go into automatic coro stuff, only traverse the body
+  return RecursiveASTVisitor<MatchASTVisitor>::TraverseStmt(CoroBody->getBody());
+}
+
 class MatchASTConsumer : public ASTConsumer {
 public:
   MatchASTConsumer(MatchFinder *Finder,
diff --git a/lib/ASTMatchers/ASTMatchersInternal.cpp b/lib/ASTMatchers/ASTMatchersInternal.cpp
index 4ee32fbe..e88e287c 100644
--- a/lib/ASTMatchers/ASTMatchersInternal.cpp
+++ b/lib/ASTMatchers/ASTMatchersInternal.cpp
@@ -852,5 +852,7 @@ const internal::VariadicDynCastAllOfMatcher<OMPClause, OMPDefaultClause>
 const internal::VariadicDynCastAllOfMatcher<Decl, CXXDeductionGuideDecl>
     cxxDeductionGuideDecl;
 
+const internal::VariadicDynCastAllOfMatcher<Stmt, CoroutineBodyStmt> coroutineBodyStmt;
+
 } // end namespace ast_matchers
 } // end namespace clang
diff --git a/lib/ASTMatchers/Dynamic/Registry.cpp b/lib/ASTMatchers/Dynamic/Registry.cpp
index 33058053..800db9b2 100644
--- a/lib/ASTMatchers/Dynamic/Registry.cpp
+++ b/lib/ASTMatchers/Dynamic/Registry.cpp
@@ -522,6 +522,9 @@ RegistryMaps::RegistryMaps() {
   REGISTER_MATCHER(voidType);
   REGISTER_MATCHER(whileStmt);
   REGISTER_MATCHER(withInitializer);
+
+  REGISTER_MATCHER(coroutineBodyStmt);
+  REGISTER_MATCHER(hasCoroutineBody);
 }
 
 RegistryMaps::~RegistryMaps() = default;
diff --git a/lib/Frontend/InitHeaderSearch.cpp b/lib/Frontend/InitHeaderSearch.cpp
index d65d1348..9d4fefe9 100644
--- a/lib/Frontend/InitHeaderSearch.cpp
+++ b/lib/Frontend/InitHeaderSearch.cpp
@@ -447,6 +447,12 @@ void InitHeaderSearch::AddDefaultIncludePaths(const LangOptions &Lang,
   if (Lang.CPlusPlus && !Lang.AsmPreprocessor &&
       HSOpts.UseStandardCXXIncludes && HSOpts.UseStandardSystemIncludes) {
     if (HSOpts.UseLibcxx) {
+      if (triple.isOSDarwin()) {
+        if(!HasSysroot) {
+            AddUnmappedPath("/Library/Developer/CommandLineTools/usr/include/c++/v1", CXXSystem, false);
+            AddUnmappedPath("/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include", CXXSystem, false);
+        }
+      }
       AddPath("/usr/include/c++/v1", CXXSystem, false);
     } else {
       AddDefaultCPlusPlusIncludePaths(Lang, triple, HSOpts);
diff --git a/lib/Rewrite/HTMLRewrite.cpp b/lib/Rewrite/HTMLRewrite.cpp
index e304fbbe..c961659d 100644
--- a/lib/Rewrite/HTMLRewrite.cpp
+++ b/lib/Rewrite/HTMLRewrite.cpp
@@ -347,7 +347,7 @@ h1 { font-size:14pt }
 }
 .macro { color: DarkMagenta; }
 
-#tooltiphint {
+" R"#tooltiphint {
   position: fixed;
   width: 50em;
   margin-left: -25em;
diff --git a/lib/Sema/SemaDeclAttr.cpp b/lib/Sema/SemaDeclAttr.cpp
index ee06f8ae..af018221 100644
--- a/lib/Sema/SemaDeclAttr.cpp
+++ b/lib/Sema/SemaDeclAttr.cpp
@@ -6616,11 +6616,17 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   // though they were unknown attributes.
   if (AL.getKind() == ParsedAttr::UnknownAttribute ||
       !AL.existsInTarget(S.Context.getTargetInfo())) {
-    S.Diag(AL.getLoc(),
-           AL.isDeclspecAttribute()
-               ? (unsigned)diag::warn_unhandled_ms_attribute_ignored
-               : (unsigned)diag::warn_unknown_attribute_ignored)
-        << AL;
+
+    if(AL.hasScope() && AL.getScopeName()->getName() == "safe_memory") {
+      S.Diag(AL.getLoc(), diag::err_unknown_safe_memory_attribute) << AL.getName();
+    }
+    else {
+	    S.Diag(AL.getLoc(),
+	           AL.isDeclspecAttribute()
+	               ? (unsigned)diag::warn_unhandled_ms_attribute_ignored
+	               : (unsigned)diag::warn_unknown_attribute_ignored)
+	        << AL;
+    }
     return;
   }
 
@@ -7340,6 +7346,70 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
 
   case ParsedAttr::AT_MSAllocator:
     handleMSAllocatorAttr(S, D, AL);
+	break;
+
+  case ParsedAttr::AT_NodeCppNakedStruct:
+    handleSimpleAttribute<NodeCppNakedStructAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryNakedStruct:
+    handleSimpleAttribute<SafeMemoryNakedStructAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppMayExtend:
+    handleSimpleAttribute<NodeCppMayExtendAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryMayExtend:
+    handleSimpleAttribute<SafeMemoryMayExtendAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppNoAwait:
+    handleSimpleAttribute<NodeCppNoAwaitAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryNoAwait:
+    handleSimpleAttribute<SafeMemoryNoAwaitAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppMemoryUnsafe:
+    handleSimpleAttribute<NodeCppMemoryUnsafeAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryMemoryUnsafe:
+    handleSimpleAttribute<SafeMemoryMemoryUnsafeAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppNonDeterministic:
+    handleSimpleAttribute<NodeCppNonDeterministicAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryNonDeterministic:
+    handleSimpleAttribute<SafeMemoryNonDeterministicAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppNoSideEffect:
+    handleSimpleAttribute<NodeCppNoSideEffectAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryNoSideEffect:
+    handleSimpleAttribute<SafeMemoryNoSideEffectAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppNoSideEffectWhenConst:
+    handleSimpleAttribute<NodeCppNoSideEffectWhenConstAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryNoSideEffectWhenConst:
+    handleSimpleAttribute<SafeMemoryNoSideEffectWhenConstAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppDeepConst:
+    handleSimpleAttribute<NodeCppDeepConstAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryDeepConst:
+    handleSimpleAttribute<SafeMemoryDeepConstAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppDeepConstWhenParams:
+    handleSimpleAttribute<NodeCppDeepConstWhenParamsAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryDeepConstWhenParams:
+    handleSimpleAttribute<SafeMemoryDeepConstWhenParamsAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_NodeCppAwaitable:
+    handleSimpleAttribute<NodeCppAwaitableAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryAwaitable:
+    handleSimpleAttribute<SafeMemoryAwaitableAttr>(S, D, AL);
+    break;
+  case ParsedAttr::AT_SafeMemoryCheckAsUserCode:
+    handleSimpleAttribute<SafeMemoryCheckAsUserCodeAttr>(S, D, AL);
     break;
   }
 }
diff --git a/lib/Sema/SemaDeclCXX.cpp b/lib/Sema/SemaDeclCXX.cpp
index 2f9e4f96..7b02e48b 100644
--- a/lib/Sema/SemaDeclCXX.cpp
+++ b/lib/Sema/SemaDeclCXX.cpp
@@ -14829,8 +14829,8 @@ bool Sema::CheckOverridingFunctionAttributes(const CXXMethodDecl *New,
   const auto *NewFT = New->getType()->getAs<FunctionProtoType>();
   const auto *OldFT = Old->getType()->getAs<FunctionProtoType>();
 
-  if (OldFT->hasExtParameterInfos()) {
-    for (unsigned I = 0, E = OldFT->getNumParams(); I != E; ++I)
+  if (OldFT->hasExtParameterInfos() || NewFT->hasExtParameterInfos()) {
+    for (unsigned I = 0, E = OldFT->getNumParams(); I != E; ++I) {
       // A parameter of the overriding method should be annotated with noescape
       // if the corresponding parameter of the overridden method is annotated.
       if (OldFT->getExtParameterInfo(I).isNoEscape() &&
@@ -14840,6 +14840,7 @@ bool Sema::CheckOverridingFunctionAttributes(const CXXMethodDecl *New,
         Diag(Old->getParamDecl(I)->getLocation(),
              diag::note_overridden_marked_noescape);
       }
+    }
   }
 
   // Virtual overrides must have the same code_seg.
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 223f1f74..12be23a2 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -39,3 +39,6 @@ add_llvm_external_project(clang-tools-extra extra)
 
 # libclang may require clang-tidy in clang-tools-extra.
 add_clang_subdirectory(libclang)
+
+# Add nodecpp here, because using LLVM_EXTERNAL_PROJECTS don't seem to work
+add_llvm_external_project(checker)
